# 噪音+图像平滑

​		图像平滑也称模糊，通常需要一个滤波器与原图计算。	

​		图像噪声是图像中一种亮度或颜色信息的随机变化(被拍摄物体本身并没有)，通常是电子噪声的表现。它一般是由扫描仪或数码相机的传感器和电路产生的，也可能是受胶片颗粒或者理想光电探测器中不可避免的的散粒噪声影响产生的。图像噪声是图像拍摄过程中不希望存在的副产品，给图像带来了错误和额外的信息

~~~python
"""
Smoothing
中值滤波
	cv::medianBlur(src, dst, ksize)损伤图像中的细线与角点，取中位数来替代像素值
	kszize内核大小 必须为奇数
归一化滤波-均值滤波
	cv::blur(src, dst, Size(w, h), Point(-1, -1))
	Size定义内核大小 w,h像素宽度
	Point指定锚点位置(被平滑点的位置)，如果是负值取核的中心点
高斯滤波
	cv::GaussianBlur(src, dst, Size(w, h), sigma_x, sigmax_y)
	Size内核大小 w,h必须是正奇数
	sigma_x, sigmax_y是x和y方向的标准方差，为0则表示使用内核计算得到
双边滤波
	cv::bilateralFilter(src, dst, pixel_dis, sigma_color, sigma_space)
	pixel_dis像素的邻域直径
	sigma_color颜色空间的标准方差
	sigma_space坐标空间的标准方差
	综合空间信息与像素值信息
	双边滤波比高斯滤波多了一个高斯核。基于像素颜色分布的高斯滤波函数，在边缘附近，当两个像素距离很近时，只有同时当颜色很接近时影响才会较大，反之，距离很近但颜色差距较大，那么平滑权重也会很小。这样就保证了边缘附近像素值的保持，起到了保边的效果
"""
~~~

# 傅里叶变换

​		傅里叶变换本质上是将空间域转换到频域，其核心思想是任何的波形都能分解成正余弦曲线的组合。一般将图像变换后使用低通或高通滤波对幅度图进行滤波操作，再进行逆变换恢复原图，最终可去除图像中的低频或高频信息

# 霍夫线变换

​		一条直线在图像二维空间可以由两个变量表示，在笛卡尔坐标系中由斜率和截距(m, b)表示y=mx+b，在极坐标系中由(r,theta)表示。

​		y=-(cos theta / sin theta)x + r/sin theta		=		r=xcos theat + ysin theta

​		对于图像中的每个点，我们都可以根据xy映射到极坐标中，一条直线能够通过在theta - r平面寻找交于一点的曲线数量来检测，越多曲线交于一点也就意味着这个交点表示的直线由更多的点组成

​		笛卡尔坐标空间中一条直线对应霍夫空间中的一个点，极坐标中点对应霍夫空间中的正弦曲线。

​		笛卡尔坐标空间中通常使用y=ax+b来描述，但是对于y=1 x=2这种并没有好的a与b来表达，因此转到极坐标空间(rho，theta)，rho表示圆点到直线的最短距离，theta表示点与x轴的夹角，极坐标可以描述垂直线的形式。

​		极坐标空间做垂线，该点直线斜率与该点垂直线的斜率乘积为-1，dy/dx * tan(theta) = -1
$$
\dfrac{\rho{sin\theta}-y}{\rho{cos\theta}-x}=-\dfrac{1}{tan\theta}
$$
​		由此得到rho=xcos(theta)+ysin(theta)

​		有了这个参数，便可以依据边缘信息计算每个不为0点到极坐标空间的映射，最终依据投票是否超过阈值来判断点，将该点代入便可方向求取直线。

~~~python
"""
cv::HoughLines(src, lines, theta, threshold)
	lines 储存检测到的直线参数对(r,theta)
	theta极角theta以弧度为单位的分辨率，默认1度(CV_PI/180)
	threshold一条直线所需最少的的曲线交点

cv::HoughLinesP(src, lines, theta, thrshold, minLineLength, maxLineGap)
	minLineLength组成一条直线最少点的数量，少于这个阈值则丢弃
	maxLineGap能被认为在一条直线上的最大距离
"""
~~~

# 霍夫圆变换

​		霍夫圆变换是将二维图像空间中一个圆转换为该圆半径、圆心横纵坐标所确定的三维参数空间中一个点的过程，因此，圆周上任意三点所确定的圆，经Hough变换后在三维参数空间应对应一点		

​		点对应的二维极径极角空间被三维的圆心点x, y还有半径r空间取代。

​		图像上每一个非零点都有可能是一个潜在的圆上的一点，在笛卡尔坐标系中圆的方程为(x-a)^2+(y-b)^2=r^2，ab为圆心，r为半径，x=a+rcons theta，y=b+rsin theta，a=x-rcos theta，b=y-rsin theta

​		在abr空间中，一个点可以确定一个唯一的圆。在笛卡尔坐标系中xy点映射到abr坐标系中就是一个三维曲线，在xy坐标系中同一个圆上的所有点的圆方程应该是一样的，他们映射到abr空间中是同一个点，所以在abr空间中有圆的总像素N个曲线相交，判断相交数量是否大于阈值

​		如果我们对一个圆求梯度，那么圆上所有的点的梯度的方向均朝向圆心

​		opencv中的霍夫圆利用了霍夫梯度法：1.利用canny得到边缘检测的二值图；2.对原始图像执行一次sobel算子，计算出所有像素的邻域梯度值；3.初始化圆心空间N(a,b)=0；4.遍历二值图中所有非零像素点，沿着梯度方向(切线的方向)划线，沿着梯度方向画线，每个点有是一个累加器，有一个线经过该点，累加器加1；5.统计排序N(a,b)；6.计算canny图像中所有的非0像素点距离圆心的距离，距离从小到大排序，选取合适的半径；7.对选取的半径设置累加器，对于满足半径r的累加器+1

~~~python
"""
cv::HoughCircles(src, circles, CV_HOUGH_GRADIENT, dp, min_dist, p1, p2, min_radius, max_radius)
	circles结果
	opencv只支持梯度计算方法
	dp=1累加图像分辨率
	min_dist检测到圆心之间的最小距离
	p1 canny边缘函数的高阈值
	p2圆心检测阈值
	能检测到的最小、最大圆半径
"""
~~~



# 形态学操作

​		最基本的形态学操作是腐蚀与膨胀，它们用于消除噪声、分割独立的图像元素或连接相邻的元素、寻找图像中明显的极大值或极小值区域。

​		膨胀是求局部最大值的操作，图像和核进行卷积，计算核覆盖区域内像素的最大值，把这个最大值赋给参考点。这样会使图像中亮区域逐渐增长。腐蚀则是求最小值。

​		开运算对图像先腐蚀再膨胀，排除小团块物体(白色区域)。闭运算先膨胀再腐蚀，排除小型黑洞(黑色区域)。形态梯度是膨胀图与腐蚀图的差，能够保留物体的边缘轮廓。顶帽运算是原图与开运算结果的差值。黑帽运算是闭运算结果与原图的差值。

~~~python
"""
cv::morphologyEx(src, dst, operation, element)
	operation形态学操作,2-开、3-闭、4-形态学梯度、5-顶帽、6-黑帽
	element内核
"""
~~~

# 图像金字塔

​		下采样-高斯金字塔，低层图像重建上层未采样图像-拉普拉斯金字塔

~~~python
"""
cv::pyrUp(src, dst, Size)
cv::pyrDown(src, dst, Size)
"""
~~~

图像阈值

​		二进制阈值0，大于阈值的设定为最大值，小于的为0；反二进制阈值1，与二进制阈值相反；截断阈值2，大于阈值的设定为最大值，小于的保持不变；阈值化3，大于阈值保持不变，小于阈值为0

Sobel算子

​		分别计算水平和垂直方向导数，本质上可以理解成求邻域范围内的像素变化

~~~python
"""
Gx	[-1, 0, 1]		Gy	[-1, -2, -1]
	[-2, 0, 2]			[0, 0, 0]
	[-1, 0, 1]			[1, 2, 1]
	
G = sqrt(Gx**2 + Gy**2)

Scharr原理和Sobel一致，但结果更加精确
Gx	[-3, 0, 3]		Gy	[-3, -10, -3]
	[-10, 0, 10]		[0, 0, 0]
	[-3, 0, 3]			[3, 10, 3]
"""
~~~

Laplacian算子

​		从二阶导数来检测边缘，边缘一阶导数会出现极值点，对该点继续求导的话为0，因此二阶导也可用来检测边缘

Canny算子

​		在sobel的基础上计算梯度方向，并且在各个方向上进行非极大值抑制，保留细线条。最后附带滞后阈值，某一像素超过高阈值则保留为边缘像素，小于低阈值则排除，在二者之间，像素仅仅在连接到一个高于高阈值的像素时才保留。Canny 推荐的 *高*:*低* 阈值比在 2:1 到3:1之间

直方图均衡化

​		按照每一个bin的像素数目来统计图像像素强度[0-255]=[0,15]+[16,31]+...+[240,255]，则划分了15个bin，最后统计每一个bin中的像素数目。直方图可以统计的不仅仅是颜色灰度， 它可以统计任何图像特征 (如 梯度, 方向等等)

​		直方图是图像中像素分布图，统计了每一个强度值所具有的像素个数。直方图均衡化是通过拉伸像素强度分布范围来增强图像对比度的一种方法。均衡化指的是把一个分布 (给定的直方图) *映射* 到另一个分布 (一个更宽更统一的强度值分布), 所以强度值分布会在整个范围内展开

~~~python
"""
cv::calcHist
	&input输入的数组
	输入数组的个数，单通道为1
	dim需要统计的通道
	Mat()掩码，未定义则不使用
	hist_results储存直方图的矩阵
	dim_results直方图的维数
	histSize每个维度bin的数目
	histRange每个维度的取值范围
	
equalizeHist( src, dst );

cv::compareHist(base, compare, compare_method)
	基准图像
	比较图像
	比较方法
	
cv::calcBackProject计算反向投影，直方图返回找图中特征
cv::mixChannels组合图像的不同通道
"""
~~~

模板匹配cv::matchTemplate

物体凸包cv::convexHull

圆形边界框cv::minEnclosingCircle

椭圆边界框cv::fitEllipse

计算轮廓或曲线长度 cv::arcLength

多边形测试cv::pointPolygonTest